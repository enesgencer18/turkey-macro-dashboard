theme_calc()+
scale_y_continuous(labels = scales::percent)+
scale_x_date(date_breaks = "2 month", date_labels =  "%m/%y")+
labs(x = "Date",
y = "",
title = "",
caption = "Source: TCMB")+
theme(plot.title = element_text(face = "italic"), legend.position = "bottom")
ggplotly(inf_plot)
load("C:/Users/egenc/Downloads/df.Rda")
View(df)
library(XML)
library(XML)
library(methods)
library(httr)
library(xts)
library(lubridate)
library(quantmod)
library(tidyverse)
Get_Cb_Data <- function(Serie = "TP.FG.J0",
Start_Date = "01-01-2013",
End_Date = lubridate::today(),
API = "4VwjGbTONS"){
URL <- paste0(
"https://evds2.tcmb.gov.tr/service/evds/series=",
paste0(Serie, collapse = "-"),
"&startDate=",
Start_Date,
"&endDate=",
format(End_Date, "%d-%m-%Y"),
"&type=xml&key=",
API
)
doc <- xmlTreeParse(GET(URL))
root <- xmlRoot(doc)
my_data <- xmlSApply(root, function(x)
xmlSApply(x, xmlValue))
my_data <- data.frame(my_data, row.names = NULL)
my_data <- t(my_data)
colnames(my_data) <- unique(names(root[2]$items))
my_data <- my_data[-1, c(1:(ncol(my_data) - 1))]
rownames(my_data) <- NULL
my_data <- as_tibble(my_data)
my_data
}
cb_series <-c(
"TP.FG.J0",
"TP.CLI2.A02",
"TP.TUFE1YI.T1",
"TP.BEK.S01.E.U",
"TP.FHGE.S01",
"TP.GY1.N2.MA",
"TP.GY4.N2.MA",
"TP.GY7.N2.MA",
"TP.ODEAYRSUNUM6.Q1",
"TP.KKO.MA",
"TP.TG2.Y03",
"TP.DT.IT.FIY.D01.2010"
)
col_names <- c(
"Date",
"CPI",
"CLI",
"Domestic_PPI",
"Inflation_Expectation",
"FS_Confidience",
"RS_Confidience",
"Production_Volume",
"Export_Orders",
"BoP",
"Utilization_Rate",
"Consumer_Confidience",
"Average_Import_Price"
)
df_list <- map(1:length(cb_series),
.f = ~Get_Cb_Data(Serie = cb_series[.x]))
df <- reduce(df_list, left_join, by = "Tarih")
colnames(df) <- col_names
usdtry <- getSymbols("USDTRY=X",
src ="yahoo",
auto.assign = FALSE) %>%
fortify() %>%
as_tibble()
usdtry <- usdtry %>%
rename(Date = Index,
Usd_Try = "USDTRY=X.Adjusted") %>%
select(Date, Usd_Try) %>%
filter(Date >= "2013-01-01") %>%
mutate(year = year(Date)) %>%
mutate(month = month(Date)) %>%
mutate(day = day(Date)) %>%
group_by(year, month) %>%
filter(day == max(day)) %>%
mutate(Date = paste0(year(Date), "-", month(Date))) %>%
ungroup() %>%
select(Date, Usd_Try)
df <- df %>%
left_join(usdtry, by = "Date")
df <- df %>%
mutate(Date = as.Date(as.yearmon(Date, format = "%Y-%m")) + months(1) - days(1)) %>%
mutate_if(.predicate = is.character, .funs = as.numeric)
df <- df %>%
mutate(Average_Import_Price = Average_Import_Price * Usd_Try)
save(df, file = "df.Rda")
rm(list = ls())
library(tidyverse)
library(zoo)
library(xts)
library(PerformanceAnalytics)
library(forecast)
library(lubridate)
library(modeltime)
library(timetk)
library(skimr)
library(tidymodels)
library(ggthemes)
load("./df.Rda")
df <- na.locf(df)
df <- df %>%
mutate(CPI = CPI/lag(CPI,12) - 1) %>%
mutate(Domestic_PPI = Domestic_PPI/lag(Domestic_PPI,12) -1) %>%
mutate(Production_Volume = Production_Volume/lag(Production_Volume, 12) -1) %>%
mutate(Export_Orders = Export_Orders/lag(Export_Orders, 12) -1) %>%
mutate(Import_Annual_Ret = Average_Import_Price/lag(Average_Import_Price, 12) -1) %>%
mutate(Import_Monthly_Ret = Average_Import_Price/lag(Average_Import_Price, 1) -1) %>%
mutate(UsdTry_Annual_Ret = Usd_Try/lag(Usd_Try, 12) -1) %>%
mutate(UsdTry_Monthly_Ret = Usd_Try/lag(Usd_Try, 1) -1) %>%
select(-Average_Import_Price, -Usd_Try) %>%
filter(Date >= "2014-01-01")
forecast_df <- df %>%
future_frame(
.date_var = Date,
.length_out = "12 months",
.bind_data = TRUE)
lag_variables <- list()
# Desired Lag Length
n = 6
# Construct A List Consisting of Lag Variables
lag_variables <- map(.x = 1:n, .f = function(i){
x <- forecast_df %>%
mutate_if(is.numeric, lag, i)
colnames(x) <- c("Date",paste0(colnames(df[,-1]), "_Lag", i))
x
})
lag_df <- reduce(lag_variables,
left_join,
by = "Date")
forecast_df <- forecast_df %>%
select(Date, CPI) %>%
left_join(lag_df,
by = "Date")
forecast_df <- forecast_df %>%
filter(Date > "2014-07-31")
forecast_df <- forecast_df %>%
mutate(Month = as.factor(month(Date)))
forecast_df$CPI_Forecast <- NA
forecast_date = as.Date(as.yearmon(today())) + months(1) - days(1)
forecast_df <- forecast_df %>%
filter(Date <= forecast_date)
forecast_tbats <- function(x){
if(is.ts(x)){
optimal_model <- tbats(x)
forecasted <- forecast(optimal_model, 1)$mean %>%
as.numeric()
forecasted
} else{
print("The provided input is not time-series object")
}
}
start_period <- 23
end_period <- nrow(forecast_df) - 1
start_year <- year(forecast_df$Date[1])
start_month <- month(forecast_df$Date[1])
forecast_df$CPI_Forecast[(start_period+1):nrow(forecast_df)] <- map_dbl(.x =start_period:end_period ,
.f = function(i){
cpi_ts <- ts(data = forecast_df$CPI[1:i],
start = c(start_year, start_month),
frequency = 12)
forecast_tbats(cpi_ts)
})
save(forecast_df, file = "./processed_data/processed_data.Rdata")
rm(list = ls())
library(tidyverse)
library(lubridate)
library(caret)
library(zoo)
load("./processed_data/processed_data.Rdata")
forecast_date = as.Date(as.yearmon(today())) + months(1) - days(1)
train_data <- forecast_df %>%
filter(Date < forecast_date)
test_data <- forecast_df %>%
filter(Date  == forecast_date)
# Construct time slices for time-series cross validation
time_slices <- trainControl(
method = "timeslice",
initialWindow = 36,
fixedWindow = TRUE,
horizon = 3,
savePredictions = TRUE,
verboseIter = TRUE
)
# Fit Regularized Regression Model
lasso_fit <- train(
CPI ~ .,
data = train_data,
na.action = "na.pass",
method = "glmnet",
preProcess = c("center", "scale"),
trControl = time_slices
)
lasso_fit
# Choose the best regularized lasso parameters
best_alpha = lasso_fit$bestTune[1] %>% pull
best_lambda = lasso_fit$bestTune[2] %>% pull
lasso_preds <- lasso_fit$pred %>%
filter(alpha == best_alpha & lambda == best_lambda)
get_predictions <- function(x){
x1 <- x %>%
filter(!Resample == unique(Resample)[length(unique(Resample))]) %>%
group_by(Resample) %>%
filter(rowIndex == min(rowIndex)) %>%
ungroup() %>%
select(rowIndex,pred, obs) %>%
rename(CPI = obs) %>%
left_join(forecast_df %>% select(Date, CPI), by = "CPI") %>%
select(Date, CPI, pred)
x2 <- x %>%
filter(Resample == unique(Resample)[length(unique(Resample))]) %>%
select(rowIndex,pred, obs) %>%
rename(CPI = obs) %>%
left_join(forecast_df %>% select(Date, CPI), by = "CPI") %>%
select(Date, CPI, pred)
res <- bind_rows(x1, x2)
res
}
lasso_preds = get_predictions(lasso_preds)
mape_vec(lasso_preds$CPI, lasso_preds$pred)
lasso_test <- tibble(Date = test_data$Date,
pred = predict(lasso_fit, test_data))
lasso_preds <- bind_rows(lasso_preds, lasso_test)
save(list = c("lasso_fit",
"lasso_preds",
"best_alpha",
"best_lambda"),file = "./analysis/ml_data.Rdata")
rm(list = ls())
library(XML)
library(methods)
library(httr)
library(xts)
library(lubridate)
library(quantmod)
library(tidyverse)
#source("~/turkey-macro-dashboard/functions/Get_Cb_Data.R")
Get_Cb_Data <- function(Serie = "TP.FG.J0",
Start_Date = "01-01-2013",
End_Date = lubridate::today(),
API = "4VwjGbTONS"){
URL <- paste0(
"https://evds2.tcmb.gov.tr/service/evds/series=",
paste0(Serie, collapse = "-"),
"&startDate=",
Start_Date,
"&endDate=",
format(End_Date, "%d-%m-%Y"),
"&type=xml&key=",
API
)
doc <- xmlTreeParse(GET(URL))
root <- xmlRoot(doc)
my_data <- xmlSApply(root, function(x)
xmlSApply(x, xmlValue))
my_data <- data.frame(my_data, row.names = NULL)
my_data <- t(my_data)
colnames(my_data) <- unique(names(root[2]$items))
my_data <- my_data[-1, c(1:(ncol(my_data) - 1))]
rownames(my_data) <- NULL
my_data <- as_tibble(my_data)
my_data
}
cb_series <-c(
"TP.FG.J0",
"TP.CLI2.A02",
"TP.TUFE1YI.T1",
"TP.BEK.S01.E.U",
"TP.FHGE.S01",
"TP.GY1.N2.MA",
"TP.GY4.N2.MA",
"TP.GY7.N2.MA",
"TP.ODEAYRSUNUM6.Q1",
"TP.KKO.MA",
"TP.TG2.Y03",
"TP.DT.IT.FIY.D01.2010"
)
col_names <- c(
"Date",
"CPI",
"CLI",
"Domestic_PPI",
"Inflation_Expectation",
"FS_Confidience",
"RS_Confidience",
"Production_Volume",
"Export_Orders",
"BoP",
"Utilization_Rate",
"Consumer_Confidience",
"Average_Import_Price"
)
df_list <- map(1:length(cb_series),
.f = ~Get_Cb_Data(Serie = cb_series[.x]))
df <- reduce(df_list, left_join, by = "Tarih")
colnames(df) <- col_names
usdtry <- getSymbols("USDTRY=X",
src ="yahoo",
auto.assign = FALSE) %>%
fortify() %>%
as_tibble()
usdtry <- usdtry %>%
rename(Date = Index,
Usd_Try = "USDTRY=X.Adjusted") %>%
select(Date, Usd_Try) %>%
filter(Date >= "2013-01-01") %>%
mutate(year = year(Date)) %>%
mutate(month = month(Date)) %>%
mutate(day = day(Date)) %>%
group_by(year, month) %>%
filter(day == max(day)) %>%
mutate(Date = paste0(year(Date), "-", month(Date))) %>%
ungroup() %>%
select(Date, Usd_Try)
df <- df %>%
left_join(usdtry, by = "Date")
df <- df %>%
mutate(Date = as.Date(as.yearmon(Date, format = "%Y-%m")) + months(1) - days(1)) %>%
mutate_if(.predicate = is.character, .funs = as.numeric)
save(df, file = "df.Rda")
rm(list = ls())
library(tidyverse)
rm(list = ls())
library(tidyverse)
library(zoo)
library(xts)
library(PerformanceAnalytics)
library(forecast)
library(lubridate)
library(modeltime)
library(timetk)
library(skimr)
library(tidymodels)
library(ggthemes)
load("./raw_data/df.Rda")
rm(list = ls())
library(tidyverse)
library(zoo)
library(xts)
library(PerformanceAnalytics)
library(forecast)
library(lubridate)
library(modeltime)
library(timetk)
load("./raw_data/df.Rda")
df <- na.locf(df)
df <- df %>%
mutate(CPI = CPI/lag(CPI,12) - 1) %>%
mutate(Domestic_PPI = Domestic_PPI/lag(Domestic_PPI,12) -1) %>%
mutate(Production_Volume = Production_Volume/lag(Production_Volume, 12) -1) %>%
mutate(Export_Orders = Export_Orders/lag(Export_Orders, 12) -1) %>%
mutate(Average_Import_Price = Average_Import_Price * Usd_Try)
mutate(Import_Annual_Ret = Average_Import_Price/lag(Average_Import_Price, 12) -1) %>%
mutate(Import_Monthly_Ret = Average_Import_Price/lag(Average_Import_Price, 1) -1) %>%
mutate(UsdTry_Annual_Ret = Usd_Try/lag(Usd_Try, 12) -1) %>%
mutate(UsdTry_Monthly_Ret = Usd_Try/lag(Usd_Try, 1) -1) %>%
select(-Average_Import_Price, -Usd_Try) %>%
filter(Date >= "2014-01-01")
View(df)
load("./raw_data/df.Rda")
df <- na.locf(df)
df <- df %>%
mutate(CPI = CPI/lag(CPI,12) - 1) %>%
mutate(Domestic_PPI = Domestic_PPI/lag(Domestic_PPI,12) -1) %>%
mutate(Production_Volume = Production_Volume/lag(Production_Volume, 12) -1) %>%
mutate(Export_Orders = Export_Orders/lag(Export_Orders, 12) -1) %>%
mutate(Average_Import_Price = Average_Import_Price * Usd_Try)
load("./raw_data/df.Rda")
df <- na.locf(df)
df <- df %>%
mutate(CPI = CPI/lag(CPI,12) - 1) %>%
mutate(Domestic_PPI = Domestic_PPI/lag(Domestic_PPI,12) -1) %>%
mutate(Production_Volume = Production_Volume/lag(Production_Volume, 12) -1) %>%
mutate(Export_Orders = Export_Orders/lag(Export_Orders, 12) -1) %>%
mutate(Average_Import_Price = Average_Import_Price * Usd_Try) %>%
mutate(Import_Annual_Ret = Average_Import_Price/lag(Average_Import_Price, 12) -1) %>%
mutate(Import_Monthly_Ret = Average_Import_Price/lag(Average_Import_Price, 1) -1) %>%
mutate(UsdTry_Annual_Ret = Usd_Try/lag(Usd_Try, 12) -1) %>%
mutate(UsdTry_Monthly_Ret = Usd_Try/lag(Usd_Try, 1) -1) %>%
select(-Average_Import_Price, -Usd_Try) %>%
filter(Date >= "2014-01-01")
forecast_df <- df %>%
future_frame(
.date_var = Date,
.length_out = "12 months",
.bind_data = TRUE)
lag_variables <- list()
# Desired Lag Length
n = 6
# Construct A List Consisting of Lag Variables
lag_variables <- map(.x = 1:n, .f = function(i){
x <- forecast_df %>%
mutate_if(is.numeric, lag, i)
colnames(x) <- c("Date",paste0(colnames(df[,-1]), "_Lag", i))
x
})
lag_df <- reduce(lag_variables,
left_join,
by = "Date")
forecast_df <- forecast_df %>%
select(Date, CPI) %>%
left_join(lag_df,
by = "Date")
forecast_df <- forecast_df %>%
filter(Date > "2014-07-31")
forecast_df <- forecast_df %>%
mutate(Month = as.factor(month(Date)))
forecast_df$CPI_Forecast <- NA
forecast_date = as.Date(as.yearmon(today())) + months(1) - days(1)
forecast_df <- forecast_df %>%
filter(Date <= forecast_date)
forecast_tbats <- function(x){
if(is.ts(x)){
optimal_model <- tbats(x)
forecasted <- forecast(optimal_model, 1)$mean %>%
as.numeric()
forecasted
} else{
print("The provided input is not time-series object")
}
}
start_period <- 23
end_period <- nrow(forecast_df) - 1
start_year <- year(forecast_df$Date[1])
start_month <- month(forecast_df$Date[1])
forecast_df$CPI_Forecast[(start_period+1):nrow(forecast_df)] <- map_dbl(.x =start_period:end_period ,
.f = function(i){
cpi_ts <- ts(data = forecast_df$CPI[1:i],
start = c(start_year, start_month),
frequency = 12)
forecast_tbats(cpi_ts)
})
save(forecast_df, file = "./processed_data/processed_data.Rdata")
rm(list = ls())
library(tidyverse)
library(lubridate)
library(caret)
library(zoo)
load("./processed_data/processed_data.Rdata")
forecast_date = as.Date(as.yearmon(today())) + months(1) - days(1)
train_data <- forecast_df %>%
filter(Date < forecast_date)
test_data <- forecast_df %>%
filter(Date  == forecast_date)
# Construct time slices for time-series cross validation
time_slices <- trainControl(
method = "timeslice",
initialWindow = 36,
fixedWindow = TRUE,
horizon = 3,
savePredictions = TRUE,
verboseIter = TRUE
)
# Fit Regularized Regression Model
lasso_fit <- train(
CPI ~ .,
data = train_data,
na.action = "na.pass",
method = "glmnet",
preProcess = c("center", "scale"),
trControl = time_slices
)
# Choose the best regularized lasso parameters
best_alpha = lasso_fit$bestTune[1] %>% pull
best_lambda = lasso_fit$bestTune[2] %>% pull
lasso_preds <- lasso_fit$pred %>%
filter(alpha == best_alpha & lambda == best_lambda)
get_predictions <- function(x){
x1 <- x %>%
filter(!Resample == unique(Resample)[length(unique(Resample))]) %>%
group_by(Resample) %>%
filter(rowIndex == min(rowIndex)) %>%
ungroup() %>%
select(rowIndex,pred, obs) %>%
rename(CPI = obs) %>%
left_join(forecast_df %>% select(Date, CPI), by = "CPI") %>%
select(Date, CPI, pred)
x2 <- x %>%
filter(Resample == unique(Resample)[length(unique(Resample))]) %>%
select(rowIndex,pred, obs) %>%
rename(CPI = obs) %>%
left_join(forecast_df %>% select(Date, CPI), by = "CPI") %>%
select(Date, CPI, pred)
res <- bind_rows(x1, x2)
res
}
lasso_preds = get_predictions(lasso_preds)
mape_vec(lasso_preds$CPI, lasso_preds$pred)
lasso_test <- tibble(Date = test_data$Date,
pred = predict(lasso_fit, test_data))
lasso_preds <- bind_rows(lasso_preds, lasso_test)
save(list = c("lasso_fit",
"lasso_preds",
"best_alpha",
"best_lambda"),file = "./analysis/ml_data.Rdata")
yardstick::mape_vec(lasso_preds$CPI, lasso_preds$pred)
